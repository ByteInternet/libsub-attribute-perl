/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of Attribute.xs. Do not edit this file, edit Attribute.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Attribute.xs"
#define PERL_NO_GET_CONTEXT
#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>

#define NEED_PL_parser
#include "ppport.h"
#include "mgx.h"

static void
my_qerror(pTHX_ SV *err)
{
    dVAR;
    if (PL_in_eval)
        sv_catsv(ERRSV, err);
    else if (PL_errors)
        sv_catsv(PL_errors, err);
    else
        Perl_warn(aTHX_ "%"SVf, SVfARG(err));
    ++PL_error_count;
}
#undef qerror
#define qerror(msg) my_qerror(aTHX_ msg)


#define PACKAGE "Sub::Attribute"
#define META_ATTR "ATTR_SUB"

#define MY_CXT_KEY PACKAGE "::_guts" XS_VERSION
typedef struct {
    AV* queue;
    I32 debug;
} my_cxt_t;
START_MY_CXT

enum {
    SA_KLASS,
    SA_CODE,
    SA_NAME,
    SA_DATA,
    SA_METHOD
};

static void
apply_handler(pTHX_ pMY_CXT_ AV* const handler){
    SV* const klass        = AvARRAY(handler)[SA_KLASS];
    SV* const code_ref     = AvARRAY(handler)[SA_CODE];
    CV* const cv           = (CV*)SvRV(code_ref);
    SV* const name         = AvARRAY(handler)[SA_NAME];
    SV* const data         = AvARRAY(handler)[SA_DATA];
    SV* const method       = AvARRAY(handler)[SA_METHOD];
    dSP;

    if(sv_true(ERRSV)){ /* dying by bad attributes */
        qerror(ERRSV);
        return;
    }

    assert(CvGV(cv));
    assert(SvTYPE(method) == SVt_PVCV);

    if(MY_CXT.debug){
        warn("apply attribute :%s%s to &%s in %"SVf,
            GvNAME(CvGV((CV*)method)),
            SvOK(data) ? form("(%"SVf")", data) : "",
            GvNAME(CvGV(cv)),
            klass
        );
    }

    PUSHMARK(SP);
    EXTEND(SP, 5);

    PUSHs(klass);
    if(!CvANON(cv)){
        mPUSHs(newRV_inc((SV*)CvGV(cv)));
    }
    else{
        PUSHs(&PL_sv_undef); /* anonymous subroutines */
    }
    PUSHs(code_ref);
    PUSHs(name);
    PUSHs(data);

    PUTBACK;

    PL_stack_sp -= call_sv(method, G_VOID | G_EVAL);

    if(sv_true(ERRSV)){
        SV* const msg = sv_newmortal();
        sv_setpvf(msg, "Can't apply attribute %"SVf" because: %"SVf, name, ERRSV);
        qerror(msg);
    }
}

static int
sa_process_queue(pTHX_ SV* const sv, MAGIC* const mg){
    dMY_CXT;
    SV**       svp = AvARRAY(MY_CXT.queue);
    SV** const end = svp + AvFILLp(MY_CXT.queue) + 1;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);

    ENTER;
    SAVETMPS;

    while(svp != end){
        apply_handler(aTHX_ aMY_CXT_ (AV*)*svp);
        svp++;

        FREETMPS;
    }

    LEAVE;

    av_clear(MY_CXT.queue);
    return 0;
}

static SV*
sa_newSVsv_share(pTHX_ SV* const sv){
    STRLEN len;
    const char* const pv = SvPV_const(sv, len);
    return newSVpvn_share(pv, len, 0U);
}

static MGVTBL hook_scope_vtbl = {
    NULL, /* get */
    NULL, /* set */
    NULL, /* len */
    NULL, /* clear */
    sa_process_queue, /* free */
    NULL, /* copy */
    NULL, /* dup */
#ifdef MGf_LOCAL
    NULL,  /* local */
#endif
};


static MGVTBL attr_handler_vtbl;


#line 154 "Attribute.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 206 "Attribute.c"

XS(XS_Sub__Attribute_CLONE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sub__Attribute_CLONE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 159 "Attribute.xs"
    MY_CXT_CLONE;
    MY_CXT.queue = newAV();
    PERL_UNUSED_VAR(items);
#line 222 "Attribute.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Sub__Attribute_MODIFY_CODE_ATTRIBUTES); /* prototype to pass -Wmissing-prototypes */
XS(XS_Sub__Attribute_MODIFY_CODE_ATTRIBUTES)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "klass, code, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 166 "Attribute.xs"
    dMY_CXT;
    HV* const hinthv = GvHVn(PL_hintgv);
    HV* stash;
    MAGIC* mg;
    I32 i;
#line 247 "Attribute.c"
	SV*	klass = ST(0);
	CV*	code;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVCV){
		    code = (CV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a CODE reference",
				"Sub::Attribute::MODIFY_CODE_ATTRIBUTES",
				"code");
		}
	} STMT_END;
#line 172 "Attribute.xs"
    mg = mg_find_by_vtbl((SV*)hinthv, &hook_scope_vtbl);
    if(!mg){
        sv_magicext((SV*)hinthv, NULL, PERL_MAGIC_ext, &hook_scope_vtbl, NULL, 0);
        PL_hints |= HINT_LOCALIZE_HH;
    }
    stash = gv_stashsv(klass, TRUE);
    klass = sa_newSVsv_share(aTHX_ klass);

    for(i = 2; i < items; i++){
        STRLEN attrlen;
        const char* const attr = SvPV_const(ST(i), attrlen);
        const char* data       = strchr(attr, '(');
        STRLEN  datalen        = attrlen - (data - attr) - 2;
        STRLEN const namelen   = data ? (STRLEN)(data - attr) : attrlen;
        GV* meth;

        if(data){
            data++; /* skip '(' */
            while(isSPACE(*data)){
                data++;
                datalen--;
            }
            while(isSPACE(data[datalen-1])){
                datalen--;
            }
        }

        if(strnEQ(attr, META_ATTR, sizeof(META_ATTR))){ /* meta attribute */
            if(!MgFind((SV*)code, &attr_handler_vtbl)){
                sv_magicext(
                    (SV*)code,
                    NULL, PERL_MAGIC_ext, &attr_handler_vtbl,
                    PACKAGE, 0
                );

                if(MY_CXT.debug){
                    warn("install attribute handler %"SVf"\n", PL_subname);
                }
            }
            continue;
        }

        meth = gv_fetchmeth_autoload(stash, attr, namelen, 0 /* special zero */);
        if(meth && MgFind((SV*)GvCV(meth), &attr_handler_vtbl)){
            AV* const handler = newAV();

            av_store(handler, SA_METHOD, SvREFCNT_inc_simple_NN((SV*)GvCV(meth)));
            av_store(handler, SA_KLASS,  SvREFCNT_inc_simple_NN(klass));
            av_store(handler, SA_CODE,   newRV_inc((SV*)code));
            av_store(handler, SA_NAME,   newSVpvn_share(attr, namelen, 0U));

            if(data){
                av_store(handler, SA_DATA,  newSVpvn(data, datalen));
            }

            av_push(MY_CXT.queue, (SV*)handler);
        }
        else{
            if(MY_CXT.debug){
                warn("ignore unrecognized attribute :%"SVf"\n", ST(i));
            }
#if PERL_BCDVERSION < 0x5008009
            /* See RT #53420 */
            {
                const char* const a = SvPV_nolen_const(ST(i));
                if(    strEQ(a, "lvalue")
                    || strEQ(a, "method")
                    || strEQ(a, "locked")
                    || strEQ(a, "unique")
                    || strEQ(a, "shared") ){
                    continue;
                }
            }
#endif
            XPUSHs(ST(i));
        }
    }
#line 341 "Attribute.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Sub__Attribute); /* prototype to pass -Wmissing-prototypes */
XS(boot_Sub__Attribute)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

        newXS("Sub::Attribute::CLONE", XS_Sub__Attribute_CLONE, file);
        newXS("Sub::Attribute::MODIFY_CODE_ATTRIBUTES", XS_Sub__Attribute_MODIFY_CODE_ATTRIBUTES, file);

    /* Initialisation Section */

#line 149 "Attribute.xs"
{
    const char* const d = PerlEnv_getenv("SUB_ATTRIBUTE_DEBUG");
    MY_CXT_INIT;
    MY_CXT.queue      = newAV();
    MY_CXT.debug      = (d && *d != '\0' && strNE(d, "0"));
}

#line 384 "Attribute.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

